## 游戏规则
控制掉落的方块，填满水平行使其消失，尝试尽可能多的消除不断掉落的方块



## 心路历程
最早是希望能有个小项目可以时不时拿来练练新出的技术，不然一直抄demo，过眼不过脑。
阅读了[用React、Redux、Immutable做俄罗斯方块](https://github.com/chvin/react-tetris)，后决定就这个项目了。然后开始读源码，试图重新造轮子。从文件夹标注这啊、那啊大致是对应哪一块业务，再一步步细分到文件、文件中的函数，拆解完后。。。2周，我感觉2周就能搞定这个项目。。。但是真正码起来却是：
卧槽，这里有个细节得打磨打磨！
欸，这样式排版要搞好还得充充电！
啊，事件整一块原来这么麻烦！
不行，这样写太啰嗦，我要重构！
时间悄咪咪就过去了，回头一看，mud, almost 2 month
真正写的时候，发现其实这个游戏简单的操作后面都是强大的逻辑在做支撑，中间踩了不少坑，像是伪随机、旋转、踢墙，以及最基本的方块的构建，都下了不少功夫。前面chvin的代码还能参考参考，后面基本上都是自己的思路了，轮子也不是说造，那么简单就能造的啊！
最后，写完感觉自己进入了贤者模式。



## 术语统一
特地写了个术语描述栏目，方便对业务进行描述，以及后续编程时进行命名
| 术语           | 别名              | 描述                                      |
| -------------- | ----------------- | ----------------------------------------- |
| 方块（数组）   | tetromino,tetrads | 俄罗斯方块的简称                          |
| 方块（对象）   | pieces            | 俄罗斯方块的简称                          |
| 方块填充       | blocks,filled     | 方块展示在矩阵上                          |
| 方格           | cell,minoes       | 组成矩阵的小格子                          |
| 矩阵           | matrix            | 由行（rows）和列（columns）组成的2维界面  |
| 形状           | shape             | 4个方块的基本排列方式                     |
| 方向           | direction,direct  | 方块的朝向，也是相对基本排列旋转90°的次数 |
| 摇杆           | joystick          | 控制方块的按钮                            |
| 游戏场地       | playField         | 游戏内容的主要展示界面                    |
| 移动点（坐标） | point,location    | 通过x轴和y轴来确定矩阵上移动的点          |
| 定位点         | origin,position   | 相对位置                                  |
| 计分板         | scoreboard        | 展示方块得分                              |



## 编码思路

基于`create-react-app` 这个脚手架搭建，轻度使用了`typescript` ，重度使用了`redux-toolkit` 。`ts` 让代码更加可读，`redux-toolkit` 则是集成了常用的全家桶，例如`thunk` ,`reselector` ,`immer` 等，这样延迟计算、记忆函数、不可变等*新鲜特性*都可以很方便的使用了。

```shell
npx create-react-app my-app --template redux-typescript
```

使用脚手架后省去了配置`webpack` 的烦恼，集成的工具库刚好够使用，这样就可以将精力都放在功能实现上了。

一开始考虑的东西不要太多太复杂，不然难以提笔。直接从最核心的部分开始，也就是矩阵和方块，考虑用怎样的数据结构来实现。以此为圆心，交互为半径，整个功能开发向周边扩散。虽然很多文章说，考虑清楚了再开发，时间80%在思考20%在编码。但真实的情况是，你硬是要想，只能发现硬不起来。没有实际可运行的代码，再多的想法都是空中楼阁。思考和编码的比例并不重要，将复杂的问题拆解后，编码即是思考，思考即是编码。

### 先开始第一步的分析

* 矩阵和方块均由2维数组构建，1和0分别表示有无填充。
* 压缩2维数组为key-value结构，value用数组存储方块所在下标。e.g. {1:[5,6,7]}表示第一行的5、6、7格有方块填充

强调一下为什么不直接用2维数组：
1. 数组会映射成`dom` ，不需要直接操作`dom` ，只需要更改`dom` 上color属性。
2. key-value结构可以很轻松的表示方块降落到了底部第20行，而2维数组做同样的表示还得有18行的0做陪跑。
3. 根据算法知识，合理压缩过的数据，可以用更少的遍历到达同样的效果，在性能上会更有优势。
4. `react` 和`redux` 均建议使用应用所需state的最小表示，然后计算出其它所有数据。

确定了2维数组后，就可以依此将整个静态的游戏界面`css` 出来了

![css流程](C:\Users\60584\Pictures\图片流程.png)

至于是只做到游戏场地的搭建还是整个红白机，就根据自己的心情来咯。

### 第二步直接啃交互这块硬骨头

对方块的操作主要有3类，降落、旋转和左右移动，对应的代码应该也至少拆分为3块逻辑。

首先，降落和移动会改变方块在矩阵上的位置，而旋转不会。所以旋转的逻辑最先拎出来，而降落和移动这样方位的改变，可以通过设置一个包含变量x, y的点对应方块所在矩阵的行和列。这样操作的逻辑就分离开来了，旋转改变的是表示方块的2维数组，降落改变的是变量y的值，移动改变的是变量x的值。因为是操作旋转后的方块做降落和移动，所以先解决方块旋转功能：

* 编写代表方块的2维数组的旋转函数
* 编写将2维数组和变量x, y转化为key-value结构

但其实并没有这么简单，旋转有顺时针和逆时针两个方向，需要编写两个函数。而且每次旋转都需要知道上一次旋转的结果，方块与方块之间又不能一概而论。这里我略作思考（想了半天），大胆的决定，只使用一个旋转函数，但是**缓存当前方块的所有旋转结果**，再通过一个**表示上下左右4个方向的变量**`direct` 来索引旋转结果。此时，`redux` 只需要

```json
  tetromino: {
    currentShape: 'J',
    direct: 0,
    },
```

极其精简的两个变量就能表示出复杂的旋转结果了。顺时针旋转，direct自增；逆时针旋转，direct自减。瞬间被自己的机智所折服。。。拿着旋转后的数组和坐标{x,y}，再通过转换函数就能得到方块展示在矩阵上的各个形状了。当然，这样的旋转其实存在bug，因为是根据左上角来旋转的，而实际需要根据方块的中点旋转。so, 在转换数组为key-value前，对每个方块的不同形状，**加入一个偏移量** 来保证方块的旋转只和方块的形状、方向有关系。巧妙的通过偏移量改变坐标{x,y}的相对位置，使得坐标始终位于方块中点。

```javascript
type Offset = [number, number]

const midPoint: { [shape in Shape]: Offset } = {
    I: [-1, 0],
    L: [-1, -1],
    J: [-1, -1],
    Z: [-1, -1],
    S: [-1, -1],
    O: [0, -1],
    T: [-1, -1],
}

const getOffset = (
    { x, y }: Point,
    offset: Offset,
) => {
    return {
        x: x + offset[0],
        y: y + offset[1],
    } as Point
}
```

本来挺复杂的方块旋转问题就这样拆解了，而操作方块降落或移动，先修改坐标还是先转换数组都可以，难度不大。但是这些操作还没有考虑交点碰撞以及边界值的问题

* 编写方块对象和矩阵对象的交点判断函数
* 编写方块对象的边界值判断函数

知晓边界条件了，就可以编写代码预测下一步能否移动，能，才调用`reducer` 修改state。到了现在，都还是一步一步操作方块的，根据游戏内容，还需要硬降功能。通过交点、高度边界的判断，递增调用软降函数，就可以求得硬降的结果了。

最为核心的方块操作交互基本搞定，可以将按钮绑定事件，验证交互的实现。

总览上文，其实思考的核心在于操作动作的拆分：

* **旋转**只和方块的形状、方向相关
* 基于旋转后的方块，**降落**只和坐标y的值相关，**移动**只和坐标x的值相关
* 是否可操作的计算，即边界值、交点问题，其实可以在组件上调用时再做判断，保持函数功能的统一性。不过硬降功能也就得拆离出去，所以直接在操作时就加入了判断（可选）
* 将操作后的结果-方块2维数组和坐标{x,y}，通过函数转换成key-value数据，也就实现了方块在矩阵上的渲染效果

### 第三步让方块自己动起来

这一步的难点并不在计时器`setInterval` 的使用，而是`playfield` 界面动作的触发以及状态的扭转。动作的触发主要为自动降落、方块填充、游戏结束，需要计算是否阻塞-->是否触底-->是否溢出。捋顺了说，触底和阻塞都会触发方块填充，完成填充后再判断是否溢出，是则游戏结束，否则继续降落。

如果游戏结束了，就从前面的动作触发变为开始结束的状态扭转，并依托于重置、暂停两个功能。重置功能-清除数据并初始化，没太多好说的。

而无论开始还是结束，游戏都处于暂停状态。如果用false表示结束，true表示开始，那么暂停时通过计算这一Boolean变量就能判断该展示开始界面还是结束界面。

如果要让组件处理逻辑更加纯粹，那么这里的逻辑会拆分到3个文件（组件）内执行：

* 一个文件使用计时器`setInterval` 实现自动降落
* 一个文件只处理方块渲染，包括填充与清除
* 一个文件做开始和结束的弹窗画面

思路大致就写到这里了，这三步基本攻破核心内容，后续的功能添加就可以按照一定的迭代计划，周期性的慢慢添加了。[俄罗斯方块指南](https://tetris.fandom.com/wiki/Tetris_Guideline) 有着对其功能丰富的说明。



## 亮点片段

某些功能的实现，自我感觉良好，所以拎出来单独表扬（狗头）。

### 伪随机系统

官方推荐的是一个叫7-bag的伪随机系统，类似于每次从包里拿出一个小球，小球一共有7个且颜色各不相同，拿完之后把小球放回重新拿。

```javascript
const randomGenerator = () => {
  let bag = 'OISZLJT'.split('') as Shape[];
  let tmp: number[] = []
  return function () {
    if (tmp.length === 0) {
      tmp = Array.from({ length: bag.length }, (_, i) => i)
    };
    const result = tmp.splice(Math.floor(Math.random() * tmp.length), 1)[0]
    return bag[result];
  }
}

let bag = randomGenerator()
```

这里利用`js` 闭包特性，让调用对象**记住**了包里还剩几个球。

### 缓存旋转结果

方块有顺时针和逆时针两种旋转，但是旋转的结果最多也就上下左右四种，所以缓存起来再通过下标来访问，就不用每次调用函数进行旋转了。

```javascript
const rotateCache = (item: Tetromino) => {
    let items = [item];

    for (
        // rotate是旋转方块的函数
        let i = rotate(item);
        items[0].length !== i.length ||
        // 判断2维数组是否相等
        items[0].some((x, y) => x.some((m, n) => i[y][n] !== m));
        i = rotate(i)
    ) {
        items.push(i);
    }
    return items;
};
```

只要写一个旋转函数，通过这个函数判断这一次和上一次的旋转结果是否相同。不同则缓存，相同则返回结果。虽然代码就是一个for循环，但是这个思路我的确琢磨了不少时间。




## 目录结构
`common`  工具代码、注释代码等弱业务相关
`components`  组件，基本渲染组件，不参与最终交互
`features`  功能区，业务逻辑主要目录，内部划分：

* 每个功能区只处理同一类型的业务
* 动作跟着状态走，共享状态就抽出来做更高一层



## Available Scripts

In the project directory, you can run:

* `npm start`
* `npm test`
* ~~`npm run build`~~
* ~~`npm run eject`~~



## 迭代计划
TODO 核心功能
* 得分榜
* 恢复游戏给出3秒倒计时

TODO 非核心功能
* 音乐
* 填充动画、消除动画
* 数据缓存
* 是否聚焦

TODO 重构
* 可以用构造函数，使矩阵数据聚合性更强。用promise完成链式关系的事件，逻辑会更清晰。
* 使用`material-UI` ,`react-hotkeys` 使得UI交互代码更直观
* 考虑使用`rxjs` ,`lodash` 简化工具代码